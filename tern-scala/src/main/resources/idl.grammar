# |  represents a logical "or"
# *  represents one or more
# +  represents at least once
# ?  represents one or none
# <> define a production
# () groups productions
# {} group productions, first match wins
# _  represents whitespace
# [] represents a symbol
# '' represents a literal text value

sign = {'-' | '+'};
number = ?<sign>{[hexadecimal] | [binary] | [decimal]};
boolean = {'true' | 'false'};
null = 'null';
literal = {<null> | <boolean> | <number> | [template] | [text]};

full-qualifier = [qualifier]*('.'[qualifier]);
wild-qualifier = [qualifier]*('.'[qualifier])'.*';

namespace = 'namespace' _ (<full-qualifier> | <wild-qualifier>) ';';

import = 'import' _ (<full-qualifier> | <wild-qualifier>) ';';
import-list = *<import>;

option = '?';

entity = [identifier] ?<option>;

attribute = [identifier];
attribute-list = '[' <attribute> *(',' <attribute>) ']';

array-length = [decimal] | [identifier];
array = [identifier] '['?<array-length>']' ?<option>;

associative-array = '['<enum-name>']' '->' [type] ?<option>;

map-key = [identifier];
map-value = {<enum-reference> | <enum-reference-list> | <literal> | [type] | <annotation-declaration> | <attribute-list>};
map-entry = (<map-key> | <literal>)':'<map-value>;
map-entry-data = <map-entry>*(','<map-entry>);

calculation-value = (<literal> | [identifier]);
calculation-operator = {'**' | '+' | '-' | '*' | '/' | '%'};
calculation-operand = <calculation-value> | '('<calculation-operand>')' | '('<calculation-list>')';
calculation-list = <calculation-operand>? _ <calculation-operator>? _ <calculation-operand> *(<calculation-operator><calculation-operand>);
calculation = <calculation-list> | '('<calculation>')';

annotation-name = [type];
annotation-list = *<annotation-declaration>?_;
annotation-declaration = '@'<annotation-name>?<annotation-attributes>;
annotation-attributes = '('?<map-entry-data>')';

struct-constraint = (<array> | <entity> | <associative-array>);
struct-value = (<calculation> | <literal> | [type]);
struct-property = ?<annotation-list>[identifier] ':' <struct-constraint> ?('=' <struct-value>) ';';
struct-extension = [type];
struct-element = (<struct-property> | <inner-struct-definition> | <inner-enum-definition> | <inner-union-definition> | <inner-interface-definition>);
struct-definition = ?<annotation-list> 'struct' _ [type] ?( _ 'extends' _ <struct-extension>) '{' *<struct-element> '}';

interface-definition = ?<annotation-list> 'interface' _ [type] ?( _ 'extends' _ <struct-extension>) '{' *<struct-element> '}';

enum-name = [type];
enum-attributes = '('?<map-entry-data>')';
enum-property = <enum-name>?<enum-attributes>;
enum-definition = ?<annotation-list> 'enum' _ [type] '{' <enum-property> *(',' <enum-property>) '}';
enum-reference = <enum-name> '.' [identifier];
enum-reference-list = '[' <enum-reference> *(',' <enum-reference>) ']';

union-property = ?<annotation-list>[identifier] ':' [type] ';';
union-requirement = [type];
union-element = (<union-property> | <inner-struct-definition> | <inner-interface-definition>);
union-definition = ?<annotation-list>'union' _ [type] ?( _ 'requires' _ <union-requirement>) '{' +<union-element> '}';

table-key = ?<annotation-list>[identifier] ':' <struct-constraint>;
table-constructor = '(' <table-key> *(',' <table-key>) ')';
table-definition = ?<annotation-list>'table' _ [type] <table-constructor> ?( 'extends' _ <struct-extension>) '{' +<struct-element> '}';

database-property = ?<annotation-list> [type];
database-requirement = [type];
database-definition = ?<annotation-list>'database' _ [type] '{' <database-property> *(',' <database-property>) '}';

alias-definition = ?<annotation-list>'alias' _ [type] '=' <struct-constraint> ';';
constant-definition = 'const' _ [identifier] '=' <struct-value> ';';

inner-enum-definition = <enum-definition>;
inner-struct-definition = <struct-definition>;
inner-union-definition = <union-definition>;
inner-interface-definition = <interface-definition>;

schema = <namespace> <import-list> *{
	<alias-definition> |
	<constant-definition> |
	<enum-definition> | 
	<struct-definition> |
	<interface-definition> |
	<union-definition> |
	<table-definition> |
	<database-definition> };

