# |  represents a logical "or"
# *  represents one or more
# +  represents at least once
# ?  represents one or none
# <> define a production
# () groups productions
# {} group productions, first match wins
# _  represents whitespace
# [] represents a symbol
# '' represents a literal text value

sign = {'-' | '+'};
number = ?<sign>{[hexadecimal] | [binary] | [decimal]};
boolean = {'true' | 'false'};
null = 'null';
literal = {<null> | <boolean> | <number> | [template] | [text]};

type-set = '{' [type]*(','[type]) '}';
path = [text];
full-qualifier = <type-set> 'from' <path>;
wild-qualifier = '*' 'from' <path>;

namespace = 'namespace' _ [qualifier]*('.'[qualifier]) ';';

import = 'import' (<full-qualifier> | <wild-qualifier>) ';';
import-list = *<import>;

attribute = [identifier];
attribute-list = '[' <attribute> *(',' <attribute>) ']';

map-key = [identifier];
map-value = {<literal> | [type] | <annotation-declaration> | <attribute-list>};
map-entry = (<map-key> | <literal>)':'<map-value>;
map-entry-data = <map-entry>*(','<map-entry>);

annotation-name = [type];
annotation-list = *<annotation-declaration>?_;
annotation-declaration = '@'<annotation-name>?<annotation-attributes>;
annotation-attributes = '('?<map-entry-data>')';

entity-constraint = [identifier];

struct-constraint = (<entity-constraint>);
struct-value = (<literal> | [type]);
struct-property = ?<annotation-list>[identifier] ':' <struct-constraint> ?('=' <struct-value>) ';';
struct-extension = [type];
struct-element = (<struct-property>);
struct-definition = ?<annotation-list> 'type' _ [type] ?( _ 'extends' _ <struct-extension>) '{' *<struct-element> '}';

source = <namespace> <import-list> *{<struct-definition>};

