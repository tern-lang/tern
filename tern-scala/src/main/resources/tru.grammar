# |  represents a logical "or"
# *  represents one or more
# +  represents at least once
# ?  represents one or none
# <> define a production
# () groups productions
# {} group productions, first match wins
# _  represents whitespace
# [] represents a symbol
# '' represents a literal text value

sign = {'-' | '+'};
number = ?<sign>{[hexadecimal] | [binary] | [decimal]};
boolean = {'true' | 'false'};
null = 'null';
literal = {<null> | <boolean> | <number> | [template] | [text]};

type-set = '{' [type]*(','[type]) '}';
path = [text];
full-qualifier = <type-set> 'from' <path>;
wild-qualifier = '*' 'from' <path>;

option = '?';

namespace = 'namespace' _ [qualifier]*('.'[qualifier]) ';';

import = 'import' (<full-qualifier> | <wild-qualifier>) ';';
import-list = *<import>;

attribute = [identifier];
attribute-list = '[' <attribute> *(',' <attribute>) ']';

map-key = [identifier];
map-value = {<literal> | [type] | <annotation-declaration> | <attribute-list>};
map-entry = (<map-key> | <literal>)':'<map-value>;
map-entry-data = <map-entry>*(','<map-entry>);

annotation-name = [type];
annotation-list = *<annotation-declaration>?_;
annotation-declaration = '@'<annotation-name>?<annotation-attributes>;
annotation-attributes = '('?<map-entry-data>')';

entity-constraint = [identifier] ?<option>;

struct-constraint = (<entity-constraint>);
struct-value = (<literal> | [type]);
struct-property = ?<annotation-list>[identifier] ':' <struct-constraint> ?('=' <struct-value>) ';';
struct-extension = [type];
struct-element = (<struct-property> |
    <inner-struct-definition> |
    <inner-enum-definition> |
    <inner-interface-definition> |
    <inner-union-definition>);

struct-definition = ?<annotation-list> 'type' _ [type] ?( _ 'extends' _ <struct-extension>) '{' *<struct-element> '}';

interface-definition = ?<annotation-list> 'interface' _ [type] ?( _ 'extends' _ <struct-extension>) '{' *<struct-element> '}';

enum-name = [type];
enum-attributes = '('?<map-entry-data>')';
enum-property = <enum-name>?<enum-attributes>;
enum-definition = ?<annotation-list> 'enum' _ [type] '{' <enum-property> *(',' <enum-property>) '}';
enum-reference = <enum-name> '.' [identifier];
enum-reference-list = '[' <enum-reference> *(',' <enum-reference>) ']';

union-property = ?<annotation-list>[identifier] ':' [type] ';';
union-requirement = [type];
union-element = (<union-property> | <inner-struct-definition> | <inner-interface-definition>);
union-definition = ?<annotation-list>'union' _ [type] ?( _ 'requires' _ <union-requirement>) '{' +<union-element> '}';

service-function = ?<annotation-list> 'def' _ [identifier] '(' [type] ')' (<service-returns> | <service-streams>) ';';
service-returns = 'returns' _ [identifier];
service-streams = 'streams' _ [identifier];
service-requirement = [type];
service-element = (<service-function> | <inner-struct-definition> | <inner-interface-definition>);
service-definition = ?<annotation-list>'service' _ [type] ?( _ 'requires' _ <service-requirement>) '{' +<service-element> '}';

inner-enum-definition = <enum-definition>;
inner-struct-definition = <struct-definition>;
inner-interface-definition = <interface-definition>;
inner-union-definition = <union-definition>;

#alias-definition = ?<annotation-list>'alias' _ [type] '=' <struct-constraint> ';';
constant-definition = 'const' _ [identifier] '=' <struct-value> ';';

source = <namespace> <import-list> *{
    <struct-definition> |
    <interface-definition> |
    <union-definition> |
    <service-definition> |
    <enum-definition> |
    <constant-definition> };

